import array as _array
import os
import shutil
import json
import csv
import pandas as pd
import h5py
import numpy as np
import sys
sys.path.append(os.path.join(os.getcwd(),"scripts"))
sys.path.append(os.path.join(os.getcwd(),"scripts/trucks"))
sys.path.append(os.getcwd())
from emme_configuration import *
from EmmeProject import *
from truck_configuration import *


def json_to_dictionary(dict_name):
    ''' Load supplemental input files as dictionary '''
    input_filename = os.path.join('inputs/model/supplementals', dict_name+'.json').replace("\\","/")
    my_dictionary = json.load(open(input_filename))

    return my_dictionary

# Load the trip productions and attractions
trip_table = pd.read_csv(trip_table_loc, index_col="taz")  # total 4K Ps and As by trip purpose
gq_trip_table = pd.read_csv(r'inputs/scenario/supplemental/generation/gq_prod_att.csv', index_col="taz")  # only group quarter Ps and As

# Import JSON inputs as dictionaries
coeff = json_to_dictionary('gravity_model')
mode_dict = json_to_dictionary('mode_dict')

# Need a new time dictionary! (updated)
'''time_dict = json_to_dictionary('time_dict')'''
time_dict = json_to_dictionary('time_dict')
purp_tod_dict = json_to_dictionary('purp_tod_dict')
mode_list = ['sov_inc2', 'hov2_inc2', 'hov3_inc2', 'trnst', 'walk', 'bike']
time_periods = time_dict['svtl'].keys()

# Import new and old trip mode 
new_mode_list = {'hbw1': ['w1shda', 'w1shs2', 'w1shs3', 'w1shtw', 'w1shbk', 'w1shwk'],
                       'hbw2': ['w2shda', 'w2shs2', 'w2shs3', 'w2shtw', 'w2shbk', 'w2shwk'],
                       'hbw3': ['w3shda', 'w3shs2', 'w3shs3', 'w3shtw', 'w3shbk', 'w3shwk'],
                       'nhb': ['nhshda', 'nhshs2', 'nhshs3', 'nhshtw',  'nhshbk', 'nhshwk'],
                       'hbo': ['nwshda', 'nwshs2', 'nwshs3', 'nwshtw',  'nwshbk', 'nwshwk']}

old_mode_list = ['svtl', 'h2tl', 'h3tl', 'trnst', 'bike', 'walk']
final_mode_list = ['sov_inc1', 'sov_inc2', 'sov_inc3', 
                   'hov2_inc1', 'hov2_inc2', 'hov2_inc3', 
                   'hov3_inc1', 'hov3_inc2', 'hov3_inc3', 
                   'transit', 'walk', 'bike']
                     
                   
# Trip purposes lists - group quarters trips are only given for home-based inc class 1 (hw1)
#trip_purp_full = ("hsp", "hbo", "sch", "wko", "col", "oto", "hw1", "hw2", "hw3", "hw4")

#Putting all external trips to hps
trip_purp_full = ('hsp',)


trip_purp_gq = ("hsp", "hbo", "sch", "wko", "col", "oto", "hw1")
# Replace old trip purpose into new purp structure
new_purp_list = ['hbw1', 'hbw2', 'hbw3', 'hbo', 'nhb']
# For old trip purposes ['wko', 'hsp', 'oto'] are combined to one trip purpose: 'nhb'
new_to_old_purp_list = {'hbw1' : 'hw1', 'hbw2' : 'hw2', 'hbw3' : 'hw3', 'hbo' : 'hbo', 'nhb' : 'nhb'}
# Final structure of trip purp
trip_purps =['hbo', 'nhb', 'hw2', 'hw3', 'hw1']

# Other inputs 
supplemental_loc = 'outputs/supplemental/'
output_dir = 'outputs/supplemental/'
ext_spg_dir = 'outputs/supplemental/ext_spg' # External and special generator trips generated by zone
gq_directory = 'outputs/supplemental/group_quarters' # Temporarily store group quarters trip table

def init_dir(directory):
    if os.path.exists(directory):
        shutil.rmtree(directory)
    os.mkdir(directory)

def load_skims(skim_file_loc, mode_name, divide_by_100=False):
    ''' Loads H5 skim matrix for specified mode. '''
    with h5py.File(skim_file_loc, "r") as f:
        skim_file = f['Skims'][mode_name][:]
    # Divide by 100 since decimals were removed in H5 source file through multiplication
    if divide_by_100:
        return skim_file.astype(float)/100
    else:
        return skim_file

def calc_fric_fac(cost_skim, dist_skim):
    ''' Calculate friction factors for all trip purposes '''
    friction_fac_dic = {}
    for purpose, coeff_val in coeff.iteritems():
        friction_fac_dic[purpose] = np.exp((coeff[purpose])*(cost_skim + (dist_skim * autoop * avotda)))
        ## Set external zones to zero to prevent external-external trips
        friction_fac_dic[purpose][LOW_STATION:] = 0
        friction_fac_dic[purpose][:,[x for x in range(LOW_STATION, len(cost_skim))]] = 0

    return friction_fac_dic

def delete_matrices(my_project, matrix_type):
    ''' Deletes all Emme matrices of specified type in emmebank '''
    for matrix in my_project.bank.matrices():
        if matrix.type == matrix_type:
            my_project.delete_matrix(matrix)

def load_matrices_to_emme(trip_table_in, trip_purps, fric_facs, my_project):
    ''' Loads data to Emme matrices: Ps and As and friction factor by trip purpose.
        Also initializes empty trip distribution and O-D result tables. '''
    #print 'in load_matrices_to_emme function: ' + trip_purps
    # list of matrix names
    matrix_name_list = [matrix.name for matrix in my_project.bank.matrices()]
    zonesDim = len(my_project.current_scenario.zone_numbers)
    zones = my_project.current_scenario.zone_numbers

    # Create Emme matrices if they don't already exist
    for purpose in trip_purps:
        print(purpose)
        if purpose + 'pro' not in matrix_name_list:
            my_project.create_matrix(str(purpose)+ "pro" , str(purpose) + " productions", "ORIGIN")
        if purpose + 'att' not in matrix_name_list:
            my_project.create_matrix(str(purpose) + "att", str(purpose) + " attractions", "DESTINATION")
        if purpose + 'fri' not in matrix_name_list:
            my_project.create_matrix(str(purpose) + "fri" , str(purpose) + "friction factors", "FULL")
        if purpose + 'dis' not in matrix_name_list:
            my_project.create_matrix(str(purpose) + "dis" , str(purpose) + "distributed trips", "FULL")
        if purpose + 'od' not in matrix_name_list:
            my_project.create_matrix(str(purpose) + "od" , str(purpose) + "O-D tables", "FULL")

        for p_a in ['pro', 'att']:
            # Load zonal production and attractions from CSV (output from trip generation)
            
            trips = np.array(trip_table_in[purpose + p_a])
            trips = np.resize(trips, zonesDim)
            #code below does not work for GQs because there are only 3700 records in the csv file. Not sure if code above is ideal.
            #trips = np.array(trip_table_in.loc[0:zonesDim - 1][purpose + p_a])    # Less 1 because NumPy is 0-based\
            matrix_id = my_project.bank.matrix(purpose + p_a).id    
            emme_matrix = my_project.bank.matrix(matrix_id)  
            emme_matrix = ematrix.MatrixData(indices=[zones],type='f')    # Access Matrix API

             # Update Emme matrix data
            emme_matrix.raw_data = _array.array('f', trips)    # set raw matrix data equal to prod/attr data
            my_project.bank.matrix(matrix_id).set_data(emme_matrix, my_project.current_scenario)

        # Load friction factors by trip purpose
        fri_fac = fric_facs[purpose][0:zonesDim,0:zonesDim]
        emme_matrix = ematrix.MatrixData(indices=[zones,zones],type='f')    # Access Matrix API
        emme_matrix.raw_data = [_array.array('f',row) for row in fri_fac]
        matrix_id = my_project.bank.matrix(purpose + "fri").id    
        my_project.bank.matrix(matrix_id).set_data(emme_matrix, my_project.current_scenario)
                  
def balance_matrices(trip_purps, my_project):
    ''' Balances productions and attractions by purpose for all internal zones '''
    for purpose in trip_purps:
        # For friction factors, have to make sure 0s in Externals are actually 0, otherwise you will get intrazonal trips
        my_project.matrix_calculator(result = 'mf' + purpose + 'fri', expression = '0', 
                                 constraint_by_zone_destinations = str(LOW_STATION) + '-' + str(HIGH_STATION), 
                                 constraint_by_zone_origins = str(LOW_STATION) + '-' + str(HIGH_STATION))
        print("Balancing trips for purpose: " + str(purpose))
        my_project.matrix_balancing(results_od_balanced_values = 'mf' + purpose + 'dis', 
                                    od_values_to_balance = 'mf' + purpose + 'fri', 
                                    origin_totals = 'mo' + purpose + 'pro', 
                                    destination_totals = 'md' + purpose + 'att', 
                                    constraint_by_zone_destinations = '1-' + str(HIGH_STATION), 
                                    constraint_by_zone_origins = '1-' + str(HIGH_STATION))

def calculate_daily_trips_externals(trip_purps, my_project):
    # Accounting for out- and in-bound trips.
    # The distribution matrices (e.g. 'mfcoldis') are in PA format. Need to convert to OD format by transposing
    #Stefan- changing code for externals- we are sending half the daily trips from external to internal. Now we need add the transpose to get the other direction. 
    for purpose in trip_purps:
        my_project.matrix_calculator(result = 'mf' + purpose + 'od', 
                                     expression = 'mf' + purpose + 'dis + mf' + purpose + 'dis'+ "'")

def calculate_daily_trips(trip_purps, my_project):
    # Accounting for out- and in-bound trips.
    # The distribution matrices (e.g. 'mfcoldis') are in PA format. Need to convert to OD format by transposing
    for purpose in trip_purps:
        my_project.matrix_calculator(result = 'mf' + purpose + 'od', 
                                     expression = '0.5*mf' + purpose + 'dis + 0.5*mf' + purpose + 'dis'+ "'")

def export_trips(split_by_mode_tod, output_dir):
    ''' Export combined trips to H5 '''
    # re-structure the mode dictionary
    # adding income levels of sov, hov
    for mode in ['svtl', 'h2tl', 'h3tl']:
            for i in ['1', '2', '3']:
                new_mode = mode + i
                mode_dict[new_mode] = mode_dict[mode]
    #deleteing the general sov, hov
    del mode_dict['svtl']
    del mode_dict['h2tl']
    del mode_dict['h3tl']

    for tod in time_periods:
        print("Exporting supplemental trips for time period: " + str(tod))
        my_store = h5py.File(output_dir + str(tod) + '.h5', "w-")
        for mode in mode_dict.keys(): 
            my_store.create_dataset(str(mode), data=split_by_mode_tod[mode][tod])
        my_store.close()

# Input the model choice ratio matrices
def apply_ratio_to_trips(trip_table, ratio_table):
    result = np.zeros(shape=trip_table.shape)
    for i in range(len(trip_table)):
        # iterate through columns
        for j in range(len(trip_table[0])):
            result[i][j] = trip_table[i][j] * ratio_table[i][j]
    print(result[:1])
    print(result[-1:])
    return result

# Apply supplemental mode choice ratios into the trip tables, which were created from trip distribution step
def repalce_previous_trip_table(new_purp_list, new_to_old_purp_list, new_mode_list, old_mode_list, trip_table_dict):
    new_trip_dict = {}
    for new_purp in new_purp_list:
        print('trip purp', new_purp, 'is transfering...')
        # read in the mode choice ratios from h5 file, which was created in "mode_choice_supplemental.py"
        mode_choice = h5py.File('outputs/supplemental/mode_choice/' + new_purp + '_ratio.h5', 'r')
        
        # re-catergory 10 purposes into 7 purposes
        # previous 10 trips purposes: ['hbo', 'sch', 'wko', 'oto', 'hw3', 'hsp', 'hw4', 'hw2', 'col', 'hw1']
        # updated to 7 purposes: ['hw1', 'hw2', 'hw3', 'nhb', 'hbo', 'sch', 'col']
        new_mode = new_mode_list[new_purp]
        old_purp = new_to_old_purp_list[new_purp]
        # hw1, hw2, are same
        if new_purp in ['hbw1', 'hbw2']:
            old_trip_table = trip_table_dict[old_purp]
        # combined hw3 and hw4 into hw3
        if new_purp in ['hw3']:
            old_trip_table = trip_table_dic['hw3'] + trip_table_dic['hw4']
        # ['wko', 'hsp', 'oto'] are combined to 'nhb'
        if new_purp in ['nhb']:
            old_trip_table = trip_table_dic['wko'] + trip_table_dic['oto']
        # ['hbo', 'hsp'] are combined to 'hbo'
        if new_purp in ['hbo']:
            old_trip_table = trip_table_dic['hbo'] + trip_table_dic['hsp']

        # compute the new trip table by applying mode choice ratio
        for i in range(6):
            # prepare the mode choice table by trip purpose
            if i > 0 and i < 3: 
                # for the hov2, hov3, divide ratio by three to account for going from 1 income category to 3
                new_ratio = mode_choice[new_purp][new_mode[i]][:] / (3)
            else: 
                new_ratio = mode_choice[new_purp][new_mode[i]][:]

            # calculate new trip table
            new_trip_table = apply_ratio_to_trips(old_trip_table , new_ratio)
            if i == 0:
                new_trip_dict[old_purp] = {old_mode_list[i] : new_trip_table }
            else:
                new_trip_dict[old_purp][old_mode_list[i]] = new_trip_table
        print(new_purp, 'finished transfered to', new_trip_dict[old_purp].keys(), 'done')

        mode_choice.close()
    return new_trip_dict

def trips_by_mode(trip_dict, trip_purp, my_project):
    inits_results = {}
    results = {}
    #divide SOV, HOV into three income levels
    for p in trip_purp:
        for m in trip_dict[p].keys():
            # home based work by income level: 1,2,3
            if m in ['svtl', 'h2tl', 'h3tl'] and p[-1:] in ['1', '2', '3']:
                n = m + p
                inits_results[n] = trip_dict[p][m]
            # nonhome based work (nhb), homebased other (hbo) (break down hov and sov by income level: 1,2,3)
            if m in ['svtl', 'h2tl', 'h3tl'] and p[-1:] in ['b', 'o']:
                for i in ['1', '2', '3']:
                    n = m + p + i
                    inits_results[n] = trip_dict[p][m]/3
            new_n = n[:4] + n[-1:]       
            # combine sov, hov by income level
            if new_n not in results.keys():
                    results[new_n] = inits_results[n]
            else:
                    results[new_n] += inits_results[n]
   
    # combine Bike, Walk, Transit
    for p in trip_purp:
        for m in trip_dict[p].keys():
            if m in ['trnst', 'walk', 'bike']:
                if m not in results.keys():
                    results[m] = trip_dict[p][m]
                else:
                    results[m] += trip_dict[p][m]
    return results
  
def trips_by_tod(trips_by_mode, trip_purps):
    ''' Distribute modal trips across times of day '''
    tod_df = {}
    trips_by_tod = {}
    #re-structural the time dictionary
    # adding factor tables for hov, sov by income levels
    for mode in ['svtl', 'h2tl', 'h3tl']:
        for i in ['1', '2', '3']:
            new_mode = mode + i
            time_dict[new_mode] = time_dict[mode]
    # deleting the general fator tables of hov, sov
    del time_dict['svtl']
    del time_dict['h2tl']
    del time_dict['h3tl']

    for mode, tod_shares in time_dict.iteritems():
        for tod in time_periods:
            if mode in trips_by_mode.keys():
                tod_df[tod] = trips_by_mode[mode] * time_dict[mode][tod]
        trips_by_tod[mode] = tod_df
        tod_df = {}
    return trips_by_tod

def distribute_trips_externals(trip_table_in, results_dir, trip_purps, fric_facs, my_project):
    ''' Load data in Emme, balance trips by purpose, and produce O-D trip tables '''
    #print 'in distribute trips function: ' + trip_purps
    # Clear all existing matrices
    delete_matrices(my_project, "ORIGIN")
    delete_matrices(my_project, "DESTINATION")
    delete_matrices(my_project, "FULL")

    # Load data into fresh Emme matrices
    load_matrices_to_emme(trip_table_in, trip_purps, fric_facs, my_project)

    # Balance matrices
    balance_matrices(trip_purps, my_project)

    # Calculate daily trips
    calculate_daily_trips_externals(trip_purps, my_project)

def split_trips(trip_dict, trip_purps, my_project):
    ''' Distribute trips by Soundcast user classes and TOD, using 2006 Survey shares '''
    by_mode = trips_by_mode(trip_dict, trip_purps, my_project)  # Distribute by mode
    by_tod = trips_by_tod(by_mode, trip_purps)  # Distribute by time of day

    return by_tod

def sum_by_purp(trip_purps, my_project):
    ''' For error checking, sum trips by trip purpose '''
    total_sum_by_purp = {}
    for purpose in trip_purps:
        # Load Emme O-D total trip data by purpose
        matrix_id = my_project.bank.matrix(purpose + 'od').id    
        emme_matrix = my_project.bank.matrix(matrix_id)  
        emme_data = emme_matrix.get_data() # Access emme data as numpy matrix
        emme_data = np.array(emme_data.raw_data, dtype='float64')
        total_sum_by_purp[purpose] = emme_data
    return total_sum_by_purp

def summarize_all_by_purp(ext_spg_summary, gq_summary, trip_purps):
    ''' For error checking, sum external, special generator, and group quarters tirps by purpose '''
    total_sum_by_purp = {}
    for purpose in trip_purps:   
    # Select only externals and special generators
        filtered = np.zeros_like(ext_spg_summary[purpose])
        # Add only special generator rows
        for loc_name, loc_zone in SPECIAL_GENERATORS.iteritems():
            # Add rows (minus 1 for zero-based NumPy index)
            #filtered[[loc_zone - 1],:] = ext_spg_summary[purpose][[loc_zone - 1],:]
            filtered[[dictZoneLookup[loc_zone]],:] = ext_spg_summary[purpose][[dictZoneLookup[loc_zone]],:]
            # Add columns (minus 1 for zero-based NumPy index)
            #filtered[:,[loc_zone - 1]] = ext_spg_summary[purpose][:,[loc_zone - 1]]
            filtered[:,[dictZoneLookup[loc_zone]]] = ext_spg_summary[purpose][:,[dictZoneLookup[loc_zone]]]
            # Combine with group quarters array
            if purpose not in ['hw2', 'hw3', 'hw4']:
                filtered += gq_summary[purpose]
        # Add only external rows and columns
        filtered[3700:,:] = ext_spg_summary[purpose][3700:,:]
        filtered[:,3700:] = ext_spg_summary[purpose][:,3700:]
        total_sum_by_purp[purpose] = filtered
    return total_sum_by_purp

def write_csv(data, file_name):
    with open(supplemental_loc + 'supplemental_summary.csv', 'wb') as f:
        csv_writer = csv.writer(f)
        csv_writer.writerows(data)

def ext_spg_selected(trip_purps):
    ''' Select only external and special generator zones '''
    total_sum_by_purp = {}
    for purpose in trip_purps:
        # Load Emme O-D total trip data by purpose
        matrix_id = my_project.bank.matrix(purpose + 'od').id    
        emme_matrix = my_project.bank.matrix(matrix_id)  
        emme_data = emme_matrix.get_data() # Access emme data as numpy matrix
        emme_data = np.array(emme_data.raw_data, dtype='float64')
        filtered = np.zeros_like(emme_data)

        # Add only external rows and columns
        filtered[3700:,:] = emme_data[3700:,:]
        filtered[:,3700:] = emme_data[:,3700:]

        total_sum_by_purp[purpose] = filtered
    return total_sum_by_purp

def supplementals_report(ext_spg_trimmed, gq_summary, combined, split_by_mode_tod):

    # Create an array to hold summary trips by purpose 
    sum_p = [[purpose for purpose in trip_purp_full]]
    sum_p[len(sum_p)-1].insert(0,"")    # Insert space for row title
    sum_p.append([ext_spg_trimmed[purp].sum() for purp in trip_purp_full]) 
    sum_p[len(sum_p)-1].insert(0,'Externals, Special Generators')  # Add row title
    sum_p.append([gq_summary[purp].sum() for purp in trip_purp_gq])
    sum_p[len(sum_p)-1].insert(0,'Group Quarters')  # Add row title
    sum_p.append([combined[purp].sum() for purp in trip_purp_full])
    sum_p[len(sum_p)-1].insert(0,'Totals')

    # Create array to hold summary trips by tod and mode
    sum_tm = [[purpose for purpose in split_by_mode_tod.keys()]]
    sum_tm[len(sum_tm)-1].insert(0,"")
    for tod in split_by_mode_tod['sov_inc1'].keys():
        sum_tm.append([split_by_mode_tod[mode][tod].sum() for mode in split_by_mode_tod.keys()])
        sum_tm[len(sum_tm)-1].insert(0, tod)    # Insert TOD row heading

    write_csv(sum_p + [[]] + sum_tm, file_name='supplemental_summary.csv')

my_project = EmmeProject(r'projects\Supplementals\Supplementals.emp')

global dictZoneLookup
dictZoneLookup = dict((value,index) for index,value in enumerate(my_project.current_scenario.zone_numbers))
    
# Load skim data
am_cost_skim = load_skims('inputs/model/roster/7to8.h5', mode_name='sov_inc2g')
am_dist_skim = load_skims('inputs/model/roster/7to8.h5', mode_name='sov_inc1d', divide_by_100=True)
pm_cost_skim = load_skims('inputs/model/roster/17to18.h5', mode_name='sov_inc2g')
pm_dist_skim = load_skims('inputs/model/roster/17to18.h5', mode_name='sov_inc1d', divide_by_100=True)
cost_skim = (am_cost_skim + pm_cost_skim) * .5
dist_skim = (am_cost_skim + pm_dist_skim) * .5
   
# Compute friction factors by trip purpose
fric_facs = calc_fric_fac(cost_skim, dist_skim)

# Create trip table for externals 
distribute_trips_externals(trip_table, ext_spg_dir, trip_purp_full, fric_facs, my_project)

#removed special generators for now
ext_spg_trimmed = ext_spg_selected(trip_purp_full)    # Include only external and special gen. zones

#Just IXXI trips for now:
ixxi_trips = ext_spg_trimmed['hsp']
svtl = ixxi_trips * .8
h2tl = ixxi_trips * .13
h3tl = ixxi_trips * .07

#write out trip table for now:
my_store = h5py.File(output_dir + '/' + 'external_non_work' + '.h5', "w")
my_store.create_dataset('svtl', data=svtl)
my_store.create_dataset('h2tl', data=h2tl)
my_store.create_dataset('h3tl', data=h3tl)

my_store.close()